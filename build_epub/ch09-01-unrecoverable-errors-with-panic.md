# Непоправимые ошибки и `panic!`

Иногда все идет настолько плохо, что лучше просто все сжечь и начать заново.
Для этого есть макрос `panic!`.

Когда программа паникует:

1.  Печатается сообщение об ошибке.
2.  Стек разматывается (unwinding) — очищаются ресурсы.
3.  Программа выходит.

Можно настроить поведение на `abort` (мгновенная смерть без очистки) в `Cargo.toml`. Это уменьшает размер бинарника, но оставляет ресурсы (память) на совести ОС.

### Как вызвать панику

```rust
fn main() {
    panic!("Crash and burn");
}
```

Или (классика):

```rust
let v = vec![1, 2, 3];
v[99]; // Паника! Выход за границы массива
```

В C вы бы получили *undefined behavior* (чтение чужой памяти, секретных ключей, фото котиков).
В Rust вы получаете безопасную остановку программы.

### Backtrace

Чтобы понять, *где* произошла ошибка, установите переменную окружения `RUST_BACKTRACE=1`.
Это покажет стек вызовов, и вы сможете найти ту самую строку, где вы ошиблись.

Чтение бэктрейса:
Ищите первую строку *вашего* кода. Всё, что выше — код ядра Rust (он, скорее всего, не виноват). Всё, что ниже — кто вызвал ваш код.

---

**Анекдот:**

> — Шеф, все пропало! База данных упала, сервер горит, клиенты в ярости!  
> — Спокойно. `panic!("Everything is fine")`.  
> — И что, помогло?  
> — Нет, но теперь это проблема операционной системы.
