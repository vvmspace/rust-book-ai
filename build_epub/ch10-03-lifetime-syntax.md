# Лайфтаймы (Lifetimes)

Лайфтаймы — это дженерики, которые гарантируют, что ссылки действительны столько, сколько нам нужно.
Обычно Rust сам понимает лайфтаймы (Lifetime Elision Rules). Но иногда ему нужна помощь.

### Проблема висячих ссылок (Dangling References)

```rust
{
    let r;
    {
        let x = 5;
        r = &x; // ОШИБКА: `x` умрет здесь, а `r` продолжит жить
    }
    println!("{}", r);
}
```
Rust не даст этому скомпилироваться. Борроу-чекер видит, что время жизни `x` меньше, чем `r`.

### Аннотации лайфтаймов

Синтаксис: `'a`. Обычно используется `'a`, `'b` и т.д.
Аннотации **не меняют** время жизни. Они просто описывают отношения между временами жизни.

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```
**Перевод:** "Функция `longest` принимает две ссылки. Обе должны жить как минимум `'a`. И возвращает она ссылку, которая живет *столько же*, сколько и параметры."
На практике `'a` будет равен *меньшему* из лайфтаймов `x` и `y`.

Если вы этого не напишете, Rust не поймет, чью ссылку мы возвращаем — `x` или `y`. А вдруг `x` живет долго, а `y` удалится через секунду?

### Лайфтаймы в структурах

Если структура держит ссылку, она обязана иметь лайфтайм.

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}
```
Экземпляр структуры не может пережить данные, на которые он ссылается.

### Static Lifetime

`'static` — значит, ссылка может жить вечно (всю программу).
Строковые литералы (`let s = "Hello"`) имеют лайфтайм `'static`.

---

**Анекдот:**

> — Доктор, сколько мне осталось жить?  
> — Это зависит от `'a`.  
> — А что такое `'a`?  
> — Это лайфтайм вашей ссылки. И судя по результатам анализов, борроу-чекер уже вызвал деструктор.
