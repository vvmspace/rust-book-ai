# Паниковать или не паниковать?

Когда использовать `panic!`, а когда `Result`?

1.  **Примеры, прототипы, тесты:** `panic!` (через `unwrap`/`expect`) — ок. Вам нужно быстро упасть, если тест не прошел.
2.  **Библиотеки:** Возвращайте `Result`. Дайте пользователю вашей библиотеки выбор.
3.  **Нарушение контракта:** Если кто-то передал вам `Index` больше `Length`, паникуйте. Это баг вызывающего кода, а не "ситуация, которую можно обработать".

### Когда у вас больше информации, чем у компилятора

```rust
use std::net::IpAddr;
let home: IpAddr = "127.0.0.1".parse().unwrap();
```

Мы знаем, что "127.0.0.1" — валидный IP. Но компилятор видит только строку.
Здесь `unwrap()` оправдан.

### Пользовательские типы для валидации

Вместо того чтобы проверять `if value > 100` в каждой функции, создайте тип `Guess`.

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }
        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```

Теперь, если у вас есть экземпляр `Guess`, вы *гарантированно* знаете, что там число от 1 до 100.
Система типов работает на вас.

---

**Анекдот:**

> — В чем смысл жизни?  
> — `42`.  
> — А если я спрошу смысл смерти?  
> — `panic!("Not implemented")`.
