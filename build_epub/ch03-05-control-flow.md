# Управление потоком

### `if` выражения

`if` в Rust — это **выражение**. Это значит, что он возвращает значение.

```rust
let condition = true;
let number = if condition { 5 } else { 6 };
```

Условие **обязано** быть `bool`. Rust не будет преобразовывать `1` в `true` или `0` в `false`. Никакой магии JS.
Если напишете `if number { ... }`, компилятор скажет: "expected `bool`, found `integer`".

### Циклы (Loops)

У нас есть три вида петель, чтобы повеси... эээ, зациклить программу:

1. **`loop`**: Бесконечный цикл. Выход через `break`.
   Можно возвращать значение из цикла: `break result * 2;`.
   
   *Лайфхак:* Если у вас вложенные циклы, можно давать им метки (labels), чтобы выходить из внешнего цикла, находясь во внутреннем: `break 'counting_up;`.

2. **`while`**: Цикл с условием. "Пока условие истинно, крутимся".

3. **`for`**: Король циклов. Самый безопасный и быстрый (да-да, компилятор его отлично оптимизирует).
   Чаще всего используется для прохода по коллекциям или диапазонам.

```rust
// Диапазон (Range) от 1 до 3 (4 не включительно). rev() разворачивает его.
for number in (1..4).rev() {
    println!("{number}!");
}
println!("LIFTOFF!!!");
```

Почему `for` лучше `while` для массивов?
В `while` вам нужно следить за индексом. Ошиблись на единичку — `panic!`.
В `for` Rust сам следит за границами и итератором.

---

**Анекдот:**

> Разговаривают два цикла:  
> — Ты чего такой грустный?  
> — Да condition false, жить не хочется.  
> — А ты попробуй `loop`, там вообще условий нет! Вечная жизнь! (пока память не кончится).
