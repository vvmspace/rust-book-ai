# Синтаксис дженериков

Дженерики позволяют писать код один раз и использовать его с разными типами.

### В функциях

```rust
fn largest<T>(list: &[T]) -> &T { ... }
```
Мы говорим: "Функция `largest` работает с типом `T`".
Пока мы не знаем, что такое `T`, но знаем, что список и возвращаемое значение — *одного* типа.

**Важно:** Чтобы сравнивать элементы (`list[0] > list[1]`), тип `T` должен реализовывать трейт `PartialOrd`. Об этом позже.

### В структурах

```rust
struct Point<T> {
    x: T,
    y: T,
}
```
Тут `x` и `y` *обязаны* быть одного типа.
`Point { x: 5, y: 10 }` — ок.
`Point { x: 5, y: 4.0 }` — **ОШИБКА**.

Если нужны разные типы:
```rust
struct Point<T, U> {
    x: T,
    y: U,
}
```

### В Enums

`Option<T>` и `Result<T, E>` — это дженерики. Вы уже с ними работали!

### В методах

```rust
impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}
```

### Производительность (Мономорфизация)

"А не тормозят ли дженерики?" — спросите вы.
**Нет.**
Rust использует *мономорфизацию* (monomorphization). Во время компиляции он создает копии вашего кода для каждого конкретного типа, который вы используете.
Если вы используете `Point<i32>` и `Point<f64>`, компилятор создаст *две разные структуры* и два набора методов.
В рантайме никаких дженериков нет. Только хардкорный, оптимизированный, конкретный код.

---

**Анекдот:**

> Дженерики в Rust как квантовая физика: пока ты не скомпилируешь код, тип `T` находится в суперпозиции всех возможных типов. Но стоит наблюдателю (компилятору) вмешаться — и он схлопывается в конкретный `i32`.
