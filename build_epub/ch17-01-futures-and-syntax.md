## `async`, `await` и фьючеры: Введение в магию ⚡

Асинхронное программирование в Rust — это как заказ пиццы. Вы звоните (вызываете асинхронную функцию), вам говорят "будет через 30 минут" (возвращают `Future`), и вы идете делать свои дела. А потом, когда звонок в дверь (await), вы забираете пиццу.
Если бы это было синхронно, вы бы стояли у телефона и смотрели в стену 30 минут.

### Ключевые слова

- **`async`**: Превращает блок кода или функцию в машину, производящую  `Future`.
- **`await`**: Ключевое слово, которое ставит выполнение на паузу, пока `Future` не будет готова.

Внимание! В Rust фьючеры **ленивые** (lazy). Если вы создадите фьючер и не сделаете ему `.await`, он ничего не сделает. Вообще ничего. Даже палец о палец не ударит. Компилятор вас об этом предупредит.

### Пример: Веб-скрапер

Мы напишем простую программу, которая скачивает содержимое двух страниц.

```rust
use trpl; // Наш учебный крейт

async fn page_title(url: &str) -> Option<String> {
    let response = trpl::get(url).await;
    let text = response.text().await;
    // ... парсим HTML ...
}

fn main() {
    trpl::block_on(async {
        let title = page_title("https://www.rust-lang.org").await;
        println!("{:?}", title);
    });
}
```

Заметьте: `main` не может быть `async`. Потому что кто-то должен запустить сам `main`. Для этого нам нужен **Рантайм** (Runtime). В нашем случае `trpl::block_on` запускает мини-рантайм (под капотом Tokio).

---

**Анекдот:**

> — Почему асинхронные программисты так много прокрастинируют?  
> — Они не прокрастинируют. Они просто вернули `Future` и нажали `await`. Выполнение начнется, когда кто-то их полл`нет (poll).
