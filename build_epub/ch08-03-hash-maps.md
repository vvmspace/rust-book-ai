# Хеш-карты (Hash Maps)

`HashMap<K, V>` хранит пары "ключ-значение".
В других языках это Dict, Map, Hash, Associative Array.

### Создание и доступ

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name); // Возвращает Option<&V>
```

### Владение

Для типов с `Copy` (i32) — копируется.
Для `String` — **перемещается (Move)**. Карта становится владельцем ключей и значений.

### Обновление

1.  **Перезапись:** `insert` с тем же ключом затрет старое значение.
2.  **Только если нет:** `entry(key).or_insert(50)`. Если ключа нет — вставит 50. Если есть — вернет ссылку на существующее.
3.  **Обновление старого:**
    ```rust
    let count = map.entry(word).or_insert(0);
    *count += 1;
    ```
    Это супер-паттерн для подсчета слов.

### Хеширование

По умолчанию используется SipHash. Это защита от DoS-атак (коллизий), но не самая быстрая.
Если нужно быстрее и плевать на безопасность — можно заменить *hasher*.

### Итоги

Векторы, строки и хеш-карты — ваши лучшие друзья. Теперь вы можете хранить данные, доступ к которым сложнее, чем просто переменная на стеке, но и возможностей больше.

В следующей главе: **Ошибки**. Паника, `Result` и почему `unwrap` — это плохо (почти всегда).

---

**Анекдот:**

> Два программиста обсуждают коллизии хешей:  
> — Какова вероятность, что мы оба закажем одно и то же пиво и нам принесут разные счета?  
> — Используем SipHash?  
> — Нет, просто бармен пьян.
