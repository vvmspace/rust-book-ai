# Определение перечисления (Enum)

Структуры группируют данные *вместе* (И ширина, И высота).
Энамы говорят, что данные могут быть *одним из* (ИЛИ V4, ИЛИ V6).

### Основы

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

Мы можем создавать экземпляры: `let four = IpAddrKind::V4;`.

### Энамы с данными

В Rust энамы могут хранить данные! И это киллер-фича.
Вместо того чтобы создавать структуру с полем `kind` и полем `address`, мы можем сделать так:

```rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));
```

Более того, варианты могут хранить *разные* типы данных:

```rust
enum IpAddr {
    V4(u8, u8, u8, u8), // Хранит 4 байта
    V6(String),         // Хранит строку
}
```

Это гораздо мощнее, чем `enum` в C/C++, где это просто именованные константы.
В Rust `enum` — это алгебраический тип данных (как в Haskell).

Вы даже можете определить методы для энамов через `impl`, как для структур.

### Option: Убийца Null

В Rust нет `null`. Вообще.
Потому что `null` — это "ошибка на миллиард долларов" (слова его создателя, Тони Хоара).
Проблема `null` в том, что вы пытаетесь использовать его как значение, и получаете панику/краш.

Вместо `null` в Rust есть `Option<T>`.

```rust
enum Option<T> {
    None,
    Some(T),
}
```

`Option<T>` и `T` — это **разные типы**.
Вы не можете сложить `Option<i8>` и `i8`. Компилятор не даст.
Вы *обязаны* проверить, есть ли там значение, прежде чем его использовать.

Это заставляет вас обрабатывать случай отсутствия значения явно. Никаких сюрпризов в продакшене.

---

**Анекдот:**

> Заходит как-то `Option<i32>` в бар.
> Бармен спрашивает:  
> — Что будете пить?
> `Option` молчит.  
> — Эй, парень, ты в порядке?
> `Option` молчит.
> Бармен (нервно): — Врача! Тут человеку плохо!
> Тут заходит прогер, делает `unwrap()`, и все видят, что внутри было пусто. Вечеринка испорчена `panic!`.
