# Векторы (`Vec<T>`)

Вектор — это резиновый массив. Он может расти, сжиматься и потреблять вашу оперативку.

### Создание

```rust
let v: Vec<i32> = Vec::new(); // Пустой вектор
let v = vec![1, 2, 3];        // Макрос vec! делает красиво
```

### Обновление

```rust
let mut v = Vec::new();
v.push(5);
v.push(6);
```
Не забывайте `mut`, если хотите что-то менять.

### Чтение

Есть два стула:

1.  **Панический стул (`&v[100]`):** Если индекса нет — программа падает (`panic!`).
2.  **Безопасный стул (`v.get(100)`):** Возвращает `Option<&T>`. Если индекса нет — возвращает `None`.

Выбирайте мудро. Если индекс приходит от пользователя — берите безопасный. Если вы уверены в своей математике — берите панический (быстрее упадет — быстрее поправите).

### Ownership и векторы

Вы не можете иметь изменяемую и неизменяемую ссылку на один и тот же вектор одновременно.

```rust
let mut v = vec![1, 2, 3];
let first = &v[0]; // Immutable borrow
v.push(6);         // Mutable borrow -> ОШИБКА!
println!("{}", first);
```

Почему? Потому что `push` может переаллоцировать вектор (переместить его в другое место памяти, если места не хватило), и ссылка `first` станет висячей (dangling pointer) на старую память. Rust не позволит вам выстрелить себе в ногу, даже если вы очень хотите.

### Итерация

```rust
for i in &v {
    println!("{}", i);
}

for i in &mut v {
    *i += 50; // Используем * для разыменования
}
```

### Хранение разных типов

Вектор хранит только один тип. Что делать, если нужно хранить разные?
Используйте `enum`!

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
];
```

Это классический трюк.

---

**Анекдот:**

> Вам может казаться, что вы владеете вектором. Но на самом деле это вектор владеет вами... и вашей памятью в куче.
