# Замыкания (Closures)

Замыкания — это анонимные функции, которые могут "захватывать" переменные вокруг себя.

### Синтаксис

```rust
let plus_one = |x| x + 1;
// С типами:
let plus_one_explicit = |x: i32| -> i32 { x + 1 };
```
Вертикальные черты `| |` — это аргументы. Как `()` у функций, только стройнее.

### Захват окружения

В отличие от функций `fn`, замыкания могут использовать переменные из той же области видимости.

```rust
let x = 4;
let equal_to_x = |z| z == x; // x доступен внутри!
let y = 4;
assert!(equal_to_x(y));
```

### Как они захватывают?

1.  `FnOnce`: Забирает владение (move). Можно вызвать один раз.
2.  `FnMut`: Одалживает мутабельно (`&mut`). Можно вызывать много раз, может менять состояние.
3.  `Fn`: Одалживает иммутабельно (`&`). Можно вызывать много раз, ничего не ломает.

Если хотите принудительно забрать владение, используйте `move`.
Это часто нужно при работе с потоками (thread spawn).

```rust
let list = vec![1, 2, 3];
thread::spawn(move || println!("From thread: {:?}", list))
    .join()
    .unwrap();
```

---

**JavaScript Analogy:**

> Замыкания в Rust похожи на Arrow Functions в JS: `(x) => x + 1`.
> Разница в том, как Rust управляет памятью: он решает, забирать ли переменные (`move`) или просто одалживать (`borrow`), в то время как JS всегда держит ссылку на Scope.





---

**English Joke:**

> I wanted to understand closures, but I got lost in the scope.
