# Синтаксис методов

Методы — это функции, которые живут внутри контекста структуры (или enum/trait).
Их первый параметр — всегда `self`.

### Определение методов

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}
```

Ключевое слово `impl` (implementation) открывает блок, где мы пишем методы для `Rectangle`.
`&self` — это сокращение для `self: &Self`. Мы заимствуем экземпляр неизменяемо.
Бывает `&mut self` (если метод меняет структуру) и просто `self` (если метод поглощает структуру, забирая владение).

Вызов: `rect1.area()`.

### Геттеры

Можно называть методы так же, как поля.
```rust
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0 
    }
}
```
Rust сам разберется: если со скобками `rect1.width()` — это метод. Без скобок — поле.

### Ассоциированные функции

Это функции внутри `impl`, но без `self`. Они как статические методы в других языках.
Часто используются как конструкторы.

```rust
impl Rectangle {
    fn square(size: u32) -> Self {
        Self { width: size, height: size }
    }
}
```

Вызов через двойное двоеточие: `let sq = Rectangle::square(3);`.

### Оператор `->`

В C++ есть `.` для объектов и `->` для указателей.
В Rust есть **автоматическое разыменование**.
`p1.distance(&p2)` работает и для значения, и для ссылки, и для указателя. Rust сам добавит `&`, `&mut` или `*`, чтобы типы сошлись. Спасибо, Rust!

---

**Анекдот:**

> — Тук-тук.  
> — Кто там?  
> — `&self`.  
> — Заходи, только ничего не трогай (immutable borrow).
>  
> — Тук-тук.  
> — Кто там?  
> — `&mut self`.  
> — Ой, опять ты. Ладно, заходи, но ты приходи один, остальных я выгнал (exclusive borrow).
