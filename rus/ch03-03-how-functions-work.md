# Как работают функции

Функции в Rust — вездесущи. Даже `main` — это функция.
Синтаксис простой: `fn name(params) { body }`.
Имена функций пишутся в `snake_case` (змеиный_стиль).

### Параметры

Аргументы тиранятся строго. Вы **обязаны** указывать тип каждого параметра.

```rust
fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
}
```

Нельзя просто написать `x`, как в Python или JS. Компилятор должен знать, сколько памяти выделить.

### Инструкции и Выражения (Statements vs Expressions)

Это важно. Rust — это язык **выражений**.

- **Инструкции (Statements)**: Делают что-то и *не возвращают значения*. Заканчиваются точкой с запятой `;`.
  - `let y = 6;`
- **Выражения (Expressions)**: Вычисляются и *возвращают значение*. Не имеют точки с запятой в конце.
  - `5 + 6`
  - `{ let x = 3; x + 1 }` (этот блок вернет 4)

### Возвращаемые значения

Функции могут возвращать значения. Тип возвращаемого значения указывается после стрелки `->`.

```rust
fn five() -> i32 {
    5
}
```

Момент истины: `5` здесь — это выражение. Если вы поставите точку с запятой (`5;`), это станет инструкцией, которая ничего не возвращает (точнее, возвращает `unit` тип `()`), и компилятор выдаст ошибку, потому что он ждал `i32`.

**Большинство ошибок новичков** — это лишняя точка с запятой в конце функции.

---

**Анекдот:**

> — Доктор, у меня проблема. Я везде ставлю точки с запятой.  
> — В Rust это не проблема, это стиль жизни. А теперь скажите "А" без точки с запятой.  
> — А  
> — Вот, вы только что вернули "А" из функции. Поздравляю!
