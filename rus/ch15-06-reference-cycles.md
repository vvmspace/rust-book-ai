# Ссылочные циклы и Утечки памяти

Rust дает гарантии безопасности памяти, но утечки памяти (memory leaks) считаются безопасными (хоть и неприятными).
С помощью `Rc` и `RefCell` можно создать цикл ссылок:
A -> B -> A.

В таком случае счетчики ссылок никогда не упадут до 0, и память никогда не освободится.

### Решение: `Weak<T>` (Слабые ссылки)

Слабая ссылка не увеличивает `strong_count`. Она живет, пока жив кто-то другой, но не удерживает объект от удаления.

Пример: Структура дерева, где дети знают о родителях.
Родитель владеет детьми (`Vec<Rc<Node>>`).
Дети ссылаются на родителя (`Weak<Node>`). Если бы дети держали `Rc<Node>`, это был бы цикл.

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}
```
Чтобы использовать `Weak` ссылку, ее нужно "проапгрейдить" до `Rc` (потому что объект мог уже умереть):
```rust
if let Some(parent_rc) = node.parent.borrow().upgrade() {
    // Теперь у нас есть валидный доступ к родителю
}
```

---

**JavaScript Analogy:**

> В JS циклические ссылки тоже бывают проблемой (особенно раньше), но современный Garbage Collector умеет их находить (Mark-and-Sweep).
> Rust не имеет GC, он использует подсчет ссылок, поэтому циклы для него фатальны (в плане утечки).





---

**English Joke:**

> I'm in a relationship with myself. It's a reference cycle.
