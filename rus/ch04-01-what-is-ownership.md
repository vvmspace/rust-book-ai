# Что такое владение?

Владение — это набор правил, по которым Rust управляет памятью.
В других языках есть два пути:

1. **Garbage Collection (Java, Python, Go)**: Специальная программа бегает и подчищает за вами мусор. Удобно, но тормозит.
2. **Ручное управление (C, C++)**: Вы сами выделяете (`malloc/new`) и освобождаете (`free/delete`) память. Быстро, но один раз забыл `free` — утечка памяти. Сделал `free` дважды — краш. Использовал память после `free` — уязвимость.

Rust выбрал третий путь: **Владение**. Память освобождается автоматически, когда переменная, владеющая ей, выходит из области видимости.

### Три главных правила владения

Запишите на подкорке:

1. У каждого значения в Rust есть переменная, которая называется его **владельцем** (owner).
2. Владелец может быть **только один** в каждый момент времени.
3. Когда владелец выходит из области видимости (scope), значение **удаляется** (dropped).

### Область видимости (Scope)

```rust
fn main() {
    {                      // s еще не существует
        let s = "hello";   // s появилась и валидна
        // делаем дела с s
    }                      // скоуп закончился, s больше нет
}
```

Пока все как везде. Но давайте поговорим про `String`.

### Тип `String`

Строковые литералы (`"hello"`) хранятся прямо в бинарнике. Они быстрые, но неизменяемые.
`String` — это данные в куче (heap). Она может расти, изменяться и быть неизвестного размера во время компиляции.

```rust
let s = String::from("hello");
```

Эта строка требует выделения памяти в куче. Кто ее освободит?
В C++ есть RAII (Resource Acquisition Is Initialization). Rust использует похожий принцип.
Когда `s` выходит из скоупа, Rust автоматически вызывает функцию `drop`, которая освобождает память.

### Перемещение (Move)

А теперь смотрите внимательно.

```rust
let x = 5;
let y = x;
```
Тут все просто. `5` — это целое число, оно помещается на стеке. У нас теперь две копии `5`.

А теперь со строками:
```rust
let s1 = String::from("hello");
let s2 = s1;
```
Что произошло?
`s1` хранит: указатель на кучу, длину и емкость (все это на стеке). Сами буквы "hello" лежат в куче.
Когда мы пишем `let s2 = s1`, мы копируем *только данные со стека* (указатель, длину...). Мы **НЕ** копируем данные в куче (это было бы дорого).

Теперь у нас две переменные указывают на одну память.
Проблема: когда они выйдут из скоупа, обе попытаются сделать `drop`. Это **Double Free Error**. Катастрофа.

Решение Rust: после `let s2 = s1`, Rust считает, что `s1` **больше не валидна**.
Если вы попробуете использовать `s1`, компилятор даст по рукам.

Это называется **Move** (перемещение). `s1` была перемещена в `s2`.

### Клонирование (Clone)

Если нам *действительно* нужна глубокая копия (deep copy) данных в куче, мы используем метод `clone`.

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2); // Работает!
```

Это дорого, но честно.

### Copy Trait

Вернемся к целым числам. Почему `x` остался валиден после присваивания `y`?
Потому что типы с фиксированным размером (целые числа, float, bool, char) реализуют трейт `Copy`. Их можно копировать тривиально (побитово). `copy` происходит автоматически и он дешевый.
Если тип реализует `Drop` (как `String`, который должен чистить память), он не может реализовать `Copy`.

---

**Анекдот:**

> — Мама, а можно я поиграю в мячик?  
> — Только если ты возьмешь на себя ownership. И помни, когда ты закончишь играть, мячик будет dropped.  
> — Но я хотел отдать его братику!  
> — Тогда это будет move. Ты больше не сможешь им играть.  
> — А если я сделаю clone?  
> — Тогда у каждого будет свой мячик, но папа разорится.
