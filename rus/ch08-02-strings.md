# Строки (UTF-8)

Строки в Rust — это боль новичка.
Причин три:

1.  Rust показывает ошибки сразу (а не когда юзер введет эмодзи).
2.  Строки — это сложно.
3.  UTF-8.

`String` — это вектор байтов (`Vec<u8>`), обернутый в гарантию, что там валидный UTF-8.

### Создание

```rust
let s = String::new();
let s = "initial".to_string();
let s = String::from("initial");
```

### Обновление

`push_str` для строки, `push` для символа.
`+` или `format!`.

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // s1 перемещен (move) и больше не доступен
```
Обратите внимание на `&s2`. Мы добавляем *ссылку* ко второй строке к *первой*.
Это эффективно, но `s1` умирает.

`format!` удобнее:
```rust
let s = format!("{}-{}-{}", s1, s2, s3); // Никто не умирает, все ссылки
```

### Индексация (Запрещена!)

В других языках `s[0]` — это нормально. В Rust — **ОШИБКА КОМПИЛЯЦИИ**.

Почему?
Потому что в UTF-8 символы могут занимать от 1 до 4 байт.
Слово "Здравствуйте".
`hello.len()` вернет 24 (байта), а не 12 (букв).
Если вы возьмете `hello[0]`, вы получите `208`. Это не буква 'З'. Это первая половинка буквы 'З'.
Вернуть половинку буквы? Rust считает, что лучше не компилироваться, чем возвращать мусор.

### Срезы (Slices)

Если вы *очень* хотите выстрелить себе в ногу:
```rust
let s = &hello[0..4]; // "Зд"
```
Но если вы ошибетесь и попадете в середину символа (`&hello[0..1]`) — **PANIC** в рантайме.

### Итерация

Лучший способ работать со строками — явно сказать, что вам нужно:

- `s.chars()` — вернет Unicode Scalar Values (буквы).
- `s.bytes()` — вернет байты.

Никогда не думайте о строках как о массиве символов. Это слоеный пирог из байтов, скаляров и графемных кластеров (то, что люди считают буквами).

---

**Анекдот:**

> — Как узнать Rust-разработчика?  
> — Спроси его, сколько символов в строке.  
> — И что он ответит?  
> — Он спросит: "Байтов? Скаляров? Или графемных кластеров?" А потом начнет плакать.
