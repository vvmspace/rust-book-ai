# Переменные и мутабельность

По умолчанию переменные в Rust **неизменяемы** (immutable). Это один из способов, которым Rust ненавязчиво подталкивает вас к написанию безопасного кода.

Попробуйте создать проект `variables` и написать такой код:

```rust,ignore
fn main() {
    let x = 5;
    println!("Значение x: {x}");
    x = 6; // ОШИБКА!
    println!("Значение x: {x}");
}
```

Компилятор сразу даст вам по рукам: "cannot assign twice to immutable variable `x`".
Зачем это нужно? Чтобы вы всегда были уверены: если переменная где-то объявлена, она не изменится мистическим образом в другом месте кода. Это спасает от кучи багов, особенно в многопоточности.

Но если очень хочется, то можно. Добавьте `mut`:

```rust
let mut x = 5;
x = 6; // Теперь работает!
```

### Константы

Константы — это как неизменяемые переменные, только они *всегда* неизменяемы и живут вечно.
Объявляются через `const`, тип обязателен.

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```
По конвенции используем SCREAMING_SNAKE_CASE.

### Затенение (Shadowing)

Вот где магия. Вы можете объявить новую переменную с *тем же именем*.

```rust
fn main() {
    let x = 5;
    let x = x + 1; // Новая переменная x, затеняющая старую

    {
        let x = x * 2; // Еще одна x, внутри скоупа
        println!("x во внутреннем скоупе: {x}"); // 12
    }

    println!("x во внешнем скоупе: {x}"); // 6
}
```

В чем отличие от `mut`?

1. Мы используем `let`, создавая *новую* переменную.
2. Мы можем поменять **тип** значения!

```rust
let spaces = "   ";
let spaces = spaces.len(); // "   " (строка) превратилась в 3 (число)
```

С `mut` так не прокатит. Rust строг к типам.

---

**Анекдот:**

> — Дорогой, ты меня слушаешь?  
> — Да, конечно... `let mut attention = attention;`  
> — Что?  
> — Ничего, дорогая, просто затенил внимание.
