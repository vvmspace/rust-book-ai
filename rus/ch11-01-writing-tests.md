# Как писать тесты

Тест в Rust — это просто функция с атрибутом `#[test]`.
Она делает три вещи:

1.  Настраивает данные.
2.  Запускает код.
3.  Проверяет результат (Assert).

### Анатомия теста

Когда вы делаете `cargo new --lib`, Rust создает для вас подарок:

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
```

Запустите `cargo test`.
Если функция паникует — тест провален. Если нет — пройден.

### Макросы для проверок

1.  `assert!(condition)`: Проверяет, что условие `true`.
2.  `assert_eq!(left, right)`: Проверяет, что `left == right`. Если нет, покажет оба значения (нужен трейт `Debug`).
3.  `assert_ne!(left, right)`: Проверяет, что `left != right`.

### Проверка паники (`should_panic`)

Иногда вы *хотите*, чтобы код паниковал (например, при валидации).

```rust
#[test]
#[should_panic(expected = "значение должно быть между 1 и 100")]
fn greater_than_100() {
    Guess::new(200);
}
```
`expected` — это подстрока ожидаемого сообщения об ошибке. Помогает убедиться, что паника произошла по *нужной* причине.

### Использование `Result` в тестах

Вместо паники можно возвращать `Result`.
Что это дает? Можно использовать оператор `?` в тестах!

```rust
#[test]
fn it_works() -> Result<(), String> {
    if 2 + 2 == 4 {
        Ok(())
    } else {
        Err(String::from("два плюс два не равно четыре"))
    }
}
```

---

**Анекдот:**

> — Почему ты плачешь?  
> — Мой тест упал.  
> — А почему ты смеешься?  
> — Потому что это был `#[should_panic]`.
