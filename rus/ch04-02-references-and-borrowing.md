# Ссылки и заимствование (Borrowing)

В прошлой серии мы узнали, что передача переменной в функцию забирает владение.
Это неудобно. Хочешь просто посчитать длину строки, а приходится возвращать строку обратно, чтобы она не исчезла.

```rust
fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();
    (s, length) // Возвращаем строку, иначе она умрет
}
```

Это уныло. Rust предлагает **ссылки** (`&`).

```rust
fn calculate_length(s: &String) -> usize { // s — это ссылка на String
    s.len()
} // s выходит из скоупа, но строка не удаляется, так как s не владеет ей
```

Синтаксис `&s1` создает ссылку, которая *ссылается* на значение `s1`, но не владеет им.
Это называется **заимствование** (borrowing). Взял почитать — верни на место.

### Изменяемые ссылки

А если мы хотим изменить то, что одолжили?

```rust
fn change(some_string: &String) {
    some_string.push_str(", world"); // ОШИБКА! Ссылки неизменяемы по умолчанию.
}
```

Нужно использовать `&mut`.

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

**ГЛАВНОЕ ПРАВИЛО RUST (The Golden Rule of Borrowing):**

В любой момент времени вы можете иметь:

- Либо **ОДНУ** изменяемую ссылку (`&mut`).
- Либо **ЛЮБОЕ КОЛИЧЕСТВО** неизменяемых ссылок (`&`).
- Но **НЕ** то и другое одновременно.

Это предотвращает **Data Races** (гонки данных). Если один пишет, а другие читают — может быть каша. Если двое пишут одновременно — каша. Rust запрещает это на этапе компиляции.

```rust
let mut s = String::from("hello");

let r1 = &s; // норм
let r2 = &s; // норм
let r3 = &mut s; // БОЛЬШАЯ ПРОБЛЕМА! r1 и r2 еще живы!

println!("{}, {}, and {}", r1, r2, r3);
```

Компилятор скажет: "cannot borrow `s` as mutable because it is also borrowed as immutable".
Владельцы `r1` и `r2` не ожидают, что данные поменяются у них под носом.

### Висячие ссылки (Dangling References)

В C++ легко создать указатель на память, которая уже освобождена.
В Rust компилятор гарантирует: ссылка всегда указывает на валидные данные.
Если данные умирают раньше ссылки — это ошибка компиляции (привет, лайфтаймы, мы встретимся позже).

---

**Анекдот:**

> — Можно я одолжу твою машину (`&Car`)?  
> — Можно.  
> — А можно я ее перекрашу (`&mut Car`)?  
> — Эээ, нет. Пока ты ее водишь, я и моя жена на нее смотрим (`&Car`, `&Car`). Вот когда мы отвернемся — крась.
