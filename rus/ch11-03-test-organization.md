# Организация тестов

Rust делит тесты на два лагеря:

1.  **Юнит-тесты (Unit Tests):** Мелкие, изолированные, имеют доступ к приватным функциям.
2.  **Интеграционные тесты (Integration Tests):** Большие, тестируют библиотеку снаружи, как это делал бы пользователь.

### Юнит-тесты

Живут в том же файле, что и код (обычно внизу).
Оборачиваются в модуль `tests` с атрибутом `#[cfg(test)]`.

```rust
// src/lib.rs

fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(internal_adder(2, 2), 4);
    }
}
```
`#[cfg(test)]` говорит компилятору: "Компилируй это только когда я делаю `cargo test`. В релизный бинарник это не суй".
**Важно:** Юнит-тесты могут тестировать приватные функции!

### Интеграционные тесты

Живут в отдельной папке `tests` (на уровне `src`).
Каждый файл там — это отдельный крейт.
Они *не* имеют доступа к приватным функциям. Они работают с вашей библиотекой как `use my_library`.

Структура:
```
my_project/
├── Cargo.toml
├── src/
│   └── lib.rs
└── tests/
    └── integration_test.rs
```

В `tests/integration_test.rs` не нужен `#[cfg(test)]`, Cargo сам знает, что это тесты.

**Итог:**
Пишите юнит-тесты для проверки логики внутри. Пишите интеграционные тесты для проверки того, как ваша библиотека выглядит снаружи.

---

**Анекдот:**

> Юнит-тест проверяет, что дверь открывается и закрывается.
> Интеграционный тест проверяет, что дверь не открывается в стену.
> Пользователь пытается войти через окно.
